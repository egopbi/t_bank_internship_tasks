# В однои из игр всех сотрудников расставили в ряд. У каждого сотрудника известен рост. и у i-го
# работника он равен аi. В некоторые моменты игры два человека, которые стоят рядом, знакомились
# и выходили из ряда. После этого левая и правая половина ряда сдвигались, чтобы не было пустоты
# между ними. Такое общение происходило до тех пор, пока в ряду есть хотя бы два сотрудника.
# авторы игры решили, что чем больше разница между людьми, которые знакомятся, тем веселее.
# Поэтому они захотели найти такой способ знакомства, чтобы суммарная разница роста людей
# которые знакомятся, была как можно больше.
# Так как они не программисты. а всего лишь авторы игр, то не знают. как найти лучший порядок.
# Помогите им решить эту задачу.
# Формат входных данных
# В первой строке входных данных дано число п - количество сотрудников (2 ≤ n ≤ 3 * 10^5).
# Во второй строке дан массив целых чисел а1, a2, ..., ар (1 ≤ ai ≤ 10^9).
# Формат выходных данных
# Выведите наибольшую суммарную разницу в росте сотрудников, которые познакомятся.


def fast_sorting(lst: list | tuple):
    lenl = len(lst)
    if lenl < 2:
        return lst
    ind = int(lenl / 2)
    pivot = lst[ind]
    left_lst = [x for i, x in enumerate(lst) if x < pivot or (x == pivot and i != ind)]
    right_lst = [lst[i] for i in range(lenl) if lst[i] > pivot]

    return fast_sorting(left_lst) + [pivot] + fast_sorting(right_lst)


n_memb = int(input())

poh: str = input()
lst_raw = poh.split(" ")
lst = [int(el) for el in lst_raw]

sort_lst_memb = fast_sorting(lst)

coins_sum = 0
if n_memb % 2 == 0:
    for i in range(n_memb // 2):
        coins_sum += sort_lst_memb[-1-i] - sort_lst_memb[i]

else:
    for i in range(n_memb // 2):
        coins_sum += sort_lst_memb[-1-i] - sort_lst_memb[i]

print(coins_sum)